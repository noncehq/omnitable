let e=new WeakMap,t=new WeakMap,r=new WeakMap,i=Symbol("anyProducer"),s=Promise.resolve(),o=Symbol("listenerAdded"),n=Symbol("listenerRemoved"),l=!1,a=!1;function f(e){if("string"!=typeof e&&"symbol"!=typeof e&&"number"!=typeof e)throw TypeError("`eventName` must be a string, symbol, or number")}function h(e){if("function"!=typeof e)throw TypeError("listener must be a function")}function u(e,r){let i=t.get(e);if(i.has(r))return i.get(r)}function d(e,t){let s="string"==typeof t||"symbol"==typeof t||"number"==typeof t?t:i,o=r.get(e);if(o.has(s))return o.get(s)}function g(e,t){t=Array.isArray(t)?t:[t];let i=!1,s=(...e)=>{},o=[],n={enqueue(e){o.push(e),s()},finish(){i=!0,s()}};for(let i of t){let t=d(e,i);t||(t=new Set,r.get(e).set(i,t)),t.add(n)}return{async next(){return o?0===o.length?(i?o=void 0:await new Promise(e=>{s=e}),this.next()):{done:!1,value:await o.shift()}:{done:!0}},async return(i){for(let i of(o=void 0,t)){let t=d(e,i);t&&(t.delete(n),0===t.size&&r.get(e).delete(i))}return s(),arguments.length>0?{done:!0,value:await i}:{done:!0}},[Symbol.asyncIterator](){return this}}}let b=e=>e===o||e===n;function y(e,t,r){if(b(t))try{l=!0,e.emit(t,r)}finally{l=!1}}class c{static get isDebugEnabled(){if("object"!=typeof globalThis.process?.env)return a;let{env:e}=globalThis.process??{env:{}};return"emittery"===e.DEBUG||"*"===e.DEBUG||a}static set isDebugEnabled(e){a=e}constructor(s={}){this.debug={},e.set(this,new Set),t.set(this,new Map),r.set(this,new Map),r.get(this).set(i,new Set),this.debug=s.debug??{},void 0===this.debug.enabled&&(this.debug.enabled=!1),this.debug.logger||(this.debug.logger=(e,t,r,i)=>{try{i=JSON.stringify(i)}catch{i=`Object with the following keys failed to stringify: ${Object.keys(i).join(",")}`}("symbol"==typeof r||"number"==typeof r)&&(r=r.toString());let s=new Date,o=`${s.getHours()}:${s.getMinutes()}:${s.getSeconds()}.${s.getMilliseconds()}`;console.log(`[${o}][emittery:${e}][${t}] Event Name: ${r}
	data: ${i}`)})}logIfDebugEnabled(e,t,r){(c.isDebugEnabled||this.debug.enabled)&&this.debug.logger(e,this.debug.name,t,r)}on(e,r){for(let i of(h(r),e=Array.isArray(e)?e:[e])){f(i);let e=u(this,i);e||(e=new Set,t.get(this).set(i,e)),e.add(r),this.logIfDebugEnabled("subscribe",i,void 0),b(i)||y(this,o,{eventName:i,listener:r})}return this.off.bind(this,e,r)}off(e,r){for(let i of(h(r),e=Array.isArray(e)?e:[e])){f(i);let e=u(this,i);e&&(e.delete(r),0===e.size&&t.get(this).delete(i)),this.logIfDebugEnabled("unsubscribe",i,void 0),b(i)||y(this,n,{eventName:i,listener:r})}}once(e){let t,r=new Promise(r=>{t=this.on(e,e=>{t(),r(e)})});return r.off=t,r}events(e){for(let t of e=Array.isArray(e)?e:[e])f(t);return g(this,e)}async emit(t,o){if(f(t),b(t)&&!l)throw TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");this.logIfDebugEnabled("emit",t,o);let n=r.get(this);if(n.has(t))for(let e of n.get(t))e.enqueue(o);if(n.has(i)){let e=Promise.all([t,o]);for(let t of n.get(i))t.enqueue(e)}let a=u(this,t)??new Set,h=e.get(this),d=[...a],g=b(t)?[]:[...h];await s;let y=await Promise.all([...d.map(async e=>{if(a.has(e))return e(o)}),...g.map(async e=>{if(h.has(e))return e(t,o)})]);return 1===y.length?y[0]:y}async emitSerial(t,r){if(f(t),b(t)&&!l)throw TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");this.logIfDebugEnabled("emitSerial",t,r);let i=u(this,t)??new Set,o=e.get(this),n=[...i],a=[...o];for(let e of(await s,n))i.has(e)&&await e(r);for(let e of a)o.has(e)&&await e(t,r)}onAny(t){return h(t),this.logIfDebugEnabled("subscribeAny",void 0,void 0),e.get(this).add(t),y(this,o,{listener:t}),this.offAny.bind(this,t)}anyEvent(){return g(this)}offAny(t){h(t),this.logIfDebugEnabled("unsubscribeAny",void 0,void 0),y(this,n,{listener:t}),e.get(this).delete(t)}clearListeners(i){for(let s of i=Array.isArray(i)?i:[i])if(this.logIfDebugEnabled("clear",s,void 0),"string"==typeof s||"symbol"==typeof s||"number"==typeof s){let e=u(this,s);e&&e.clear();let t=d(this,s);if(t){for(let e of t)e.finish();t.clear()}}else{for(let[r,i]of(e.get(this).clear(),t.get(this).entries()))i.clear(),t.get(this).delete(r);for(let[e,t]of r.get(this).entries()){for(let e of t)e.finish();t.clear(),r.get(this).delete(e)}}}listenerCount(i){i=Array.isArray(i)?i:[i];let s=0;for(let o of i){if("string"==typeof o){s+=e.get(this).size+(u(this,o)?.size??0)+(d(this,o)?.size??0)+(d(this)?.size??0);continue}for(let r of(void 0!==o&&f(o),s+=e.get(this).size,t.get(this).values()))s+=r.size;for(let e of r.get(this).values())s+=e.size}return s}bindMethods(e,t){if("object"!=typeof e||null===e)throw TypeError("`target` must be an object");for(let r of t=function(e){if(void 0===e)return m;if(!Array.isArray(e))throw TypeError("`methodNames` must be an array of strings");for(let t of e)if(!m.includes(t)){if("string"!=typeof t)throw TypeError("`methodNames` element must be a string");throw Error(`${t} is not Emittery method`)}return e}(t)){if(void 0!==e[r])throw Error(`The property \`${r}\` already exists on \`target\``);Object.defineProperty(e,r,{enumerable:!1,value:this[r].bind(this)})}}}let m=Object.getOwnPropertyNames(c.prototype).filter(e=>"constructor"!==e);Object.defineProperty(c,"listenerAdded",{value:o,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(c,"listenerRemoved",{value:n,writable:!1,enumerable:!0,configurable:!1});export{c as default};